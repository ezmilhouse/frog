{\rtf1\ansi\ansicpg1252\cocoartf1343\cocoasubrtf140
\cocoascreenfonts1{\fonttbl\f0\fmodern\fcharset0 Courier-Bold;\f1\fmodern\fcharset0 Courier;\f2\fnil\fcharset0 Monaco;
}
{\colortbl;\red255\green255\blue255;}
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\sl360\slmult1\slleading160\pardirnatural

\f0\b\fs24 \cf0 \ul \ulc0 BASH
\f1\b0 \ulnone \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\sl360\slmult1\slleading160\partightenfactor0
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\sl360\slmult1\slleading160\partightenfactor0

\f0\b NAVIGATE DIRECTORIES
\f1\b0 \
$ cd 		// back home\
$ cd ..		// one up\
$ cd -		// back to previous directory\
\

\f0\b CREATE DIRECTORIES
\f1\b0 \
$ mkdir tmp			// create dir\
$ mkdir -p tmp/test	// create dir recursively\
\

\f0\b COPY
\f1\b0 \
$ cp -R -n origin destination	// -R subtree from this point, -n do not overwrite existing file\
\

\f0\b INSTALL SOFTWARE: ALL USERS
\f1\b0 \
$ /usr/local		// application folders\
$ /usr/local/bin	// application binaries\
\

\f0\b INSTALL SOFTWARE: LOCAL USER /~
\f1\b0 \
$ /Users/[USERNAME]	// or cd  \
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\slleading160\pardirnatural

\f0\b \ul BASH PROFILE
\f1\b0 \ulnone \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\sl360\slmult1\slleading160\partightenfactor0

\f0\b \
EDIT (in /~)
\f1\b0 \
$ cd\
$ nano .bash_profile\
\

\f0\b RELOAD (in /~)
\f1\b0 \
$ cd\
$ . ~/.bash_profile\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\sl360\slmult1\slleading160\pardirnatural

\f0\b \ul HOST
\f1\b0 \ulnone \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\sl360\slmult1\slleading160\partightenfactor0
Add local hosts by editing the `hosts` file in Mac OS X, add IP/TLD pairs to access local hosts in the browser, if it doesn't work immediately after saving, flush the host cache.\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\sl360\slmult1\slleading160\partightenfactor0

\f0\b EDIT HOSTFILE
\f1\b0 \
$ sudo nano /private/etc/hosts\
\

\f0\b FLUSH CACHE AFTER HOSTFILE
\f1\b0 \
$ dscacheutil -flushcache; sudo killall -HUP mDNSResponder\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\sl360\slmult1\slleading160\pardirnatural

\f0\b \ul \
MONGO DB\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\sl360\slmult1\slleading160\pardirnatural
\ulnone INSTALL\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\sl360\slmult1\slleading160\pardirnatural

\f1\b0 $ mkdir -p /usr/local/tmp
\f0\b \

\f1\b0 $ cd /usr/local/tmp\
$ curl -O http://downloads.mongodb.org/osx/mongodb-osx-x86_64-2.6.4.tgz\
$ tar -zxvf mongodb-osx-x86_64-2.6.4.tgz\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\sl360\slmult1\slleading160\partightenfactor0
$ cp -R -n mongodb-osx-x86_64-2.6.4/ mongodb\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\sl360\slmult1\slleading160\partightenfactor0

\f0\b CLI
\f1\b0 \
$ mongo\
\
# DOCKER 101\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\sl360\slmult1\slleading160\partightenfactor0

\f2 \uc0\u9500 \u9472 \u9472 
\f1  Docker\

\f2 \uc0\u9474 
\f1    
\f2 \uc0\u9500 \u9472 \u9472 
\f1  Dockerfile\

\f2 \uc0\u9474 
\f1    
\f2 \uc0\u9500 \u9472 \u9472 
\f1  nginx\

\f2 \uc0\u9474 
\f1    
\f2 \uc0\u9474 
\f1    
\f2 \uc0\u9492 \u9472 \u9472 
\f1  default\

\f2 \uc0\u9474 
\f1    
\f2 \uc0\u9500 \u9472 \u9472 
\f1  mongodb\

\f2 \uc0\u9474 
\f1    
\f2 \uc0\u9474 
\f1    
\f2 \uc0\u9492 \u9472 \u9472 
\f1  default.conf\

\f2 \uc0\u9474 
\f1    
\f2 \uc0\u9492 \u9472 \u9472 
\f1  node\

\f2 \uc0\u9474 
\f1        
\f2 \uc0\u9492 \u9472 \u9472 
\f1  default.conf\

\f2 \uc0\u9500 \u9472 \u9472 
\f1  Vagrantfile\

\f2 \uc0\u9492 \u9472 \u9472 
\f1  www\
    
\f2 \uc0\u9492 \u9472 \u9472 
\f1  index.js\
    
\f2 \uc0\u9492 \u9472 \u9472 
\f1  ...\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\slleading160\pardirnatural

\f0\b \ul BOOT2DOCKER
\f1\b0 \ulnone \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\sl360\slmult1\slleading160\partightenfactor0
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\sl360\slmult1\slleading160\partightenfactor0

\f0\b Mac OS X MOUNTING PROBLEMS
\f1\b0 \
The problem with the boot2docker VM is, that Docker is trying to mount the local path from the host into our container, but the host is boot2docker, not OS X. boot2docker doesn\'92t know anything about files on OS X. \
\
Mount OS X\'92s /Users directory into the VM.\
\
By mounting /Users into our VM, boot2docker gains a /Users volume that points to the same directory on OS X. Referencing /Users/Chris/web inside boot2docker now points directly to /Users/Chris/web on OS X, and we can mount any path starting with /Users into our container. Pretty neat.\
\
boot2docker doesn\'92t support the VirtualBox Guest Additions that allow us to make this work. Fortunately, a very smart person has solved this problem for us with a custom build of boot2docker containing the Guest Additions and the configuration to make this all work. We just have to install it.\
\
$ curl http://static.dockerfiles.io/boot2docker-v1.2.0-virtualbox-guest-additions-v4.3.14.iso > ~/.boot2docker/boot2docker.iso\
$ VBoxManage sharedfolder add boot2docker-vm -name home -hostpath /Users\
$ boot2docker up\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\slleading160\pardirnatural

\f0\b \ul DOCKER
\f1\b0 \ulnone \
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\sl360\slmult1\slleading160\partightenfactor0
\
QUICKSTART\
\
$ docker run -d -p 80:80 --name=nginx local/ubuntu-nginx\
$ docker run -d --name=mongodb local/ubuntu-mongodb\
$ docker run -d -p 2000:2000 --name=node --link mongodb:mongodb -v /Users/mfu/brnfck/test/www/project-node/htdocs:/var/www/project-node/htdocs local/ubuntu-node\
\
oder\
\
$ docker run --rm -t -i -p 2000:2000 --name=node --link mongodb:mongodb -v /Users/mfu/brnfck/test/www/project-node/htdocs:/var/www/project-node/htdocs local/ubuntu-node /bin/bash\
\
oder \
\
$ docker run --rm --name=node1 --link mongodb:mongodb local/ubuntu-node env\
$ docker run -t -i -v /var/data/mongodb --rm --name=mongodb-data local/busybox-data /bin/sh\
\
\
Important notes in random order:\
\
- the number of commands in a Dockerfile is limited to 127 layers, therefore use RUN / a lot\
https://docs.docker.com/userguide/dockerimages/\
\
- while working with docker you will run into the `upstart` problem - Some apt packages, ex. mongodb \'96 will try and start themselves up as services, the way they normally do on Linux systems, upstart and init.d services do not work inside Docker containers so we need to essentially neuter the binary responsible for this, usually you have to edit their config file by adding something similar to DAEMON=OFF\
\
- containers have an internal network and an IP address, use `docker inspect` to get an overview of a container's current network configuration\
\
- be aware of the different ways on how you can use the -p flag, you can avoidbeing constrained to only one container on a specific port, see https://docs.docker.com/userguide/dockerlinks/\
\
- if using mongodb, use a --link(ed) scenario, in node use interna IP expose by ... env to connect to database, run database container without exposing IP to the network.\
\
- data volumes persist ONLY until no containers use them\
\
- if running nodemon in a mounted folder (via -v local:container) then you should use the -L flag, otherwise it does not work (means: does not restart after changes)\
\
- while you have to run a command when you start up a container (with `run`), it doesn't really matter what the command is. It can even be a command that essentially does nothing, as ex: `true`.\
\
- you don't have to daemonize a data-only container by passing the -d option. In fact, the docker container exits immediately (after running ex: `true`), but even so, it is still usable as a data volume, even in a stopped state\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\sl360\slmult1\slleading160\partightenfactor0

\f0\b MAC OS X: INIT
\f1\b0 \
$ /usr/local/bin/boot2docker start\
$ export DOCKER_HOST=tcp://192.168.59.103:2375\
$ docker info\
\
# if you need to find out the boot2docker ip\
$ boot2docker ip\
\
If you already added export to your bash script, just run:\
$ docker info\
\
# show version\
$ docker version\
\

\f0\b IMAGES\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\sl360\slmult1\slleading160\partightenfactor0

\f1\b0 # build\
$ docker build -t="user/tag" --force-rm=false .\
\
# build: options\
--force-rm	always remove intermediate images, even after unsuccessful builds\
--no-cache  does not cache builds if set to `true`\
-t			tag to be applied to the resulting image only, in case of success, unsuccessful builds 			result in untagged (<none>) images \
\
# remove untagged images\
$ docker rmi -f $(docker images -a | grep '^<none>' | awk '\{print $3\}')\
\
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\sl360\slmult1\slleading160\partightenfactor0

\f0\b CONTAINERS
\f1\b0 \

\f0\b # inspect
\f1\b0 \
# containers low-level configuration\
$ docker inspect [CONTAINER]\
\

\f0\b # logs
\f1\b0 \
# see container's STDOUT \
$ docker logs [CONTAINER]\
\
# tail container's STDOUT\
$ docker logs -f [CONTAINER]\
\

\f0\b # ps
\f1\b0 \
# show list of running containers\
$ docker ps\
\
# show all containers\
$ docker ps -a\
\

\f0\b # rm
\f1\b0 \
# remove container(s)\
$ docker rm [CONTAINER] [CONTAINER] [CONTAINER]\
\
# remove all containers\
$ docker ps -a -q | xargs -n 1 -I \{\} docker rm \{\}\
\
# remove all exited containers\
$ docker ps -a | grep Exit | cut -d ' ' -f 1 | xargs docker rm\
\

\f0\b # run
\f1\b0 \
# run container (with port mapping, as daemon)\
$ docker run -d -p 80:80 --name=nginx --rm local/ubuntu-nginx\
\
# run container (with port mapping)\
$ docker run -t -i -p 80:80 --name=nginx --rm user/tag /bin/bash \
\
# run container to lookup `env` variables of a source container in a --link(ed) setting\
$ docker run --rm --name=node1 --link mongodb:mongodb local/ubuntu-node env\
\

\f0\b # run: env
\f1\b0 \
PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin\
HOSTNAME=8456414d86bb\
MONGODB_PORT=tcp://172.17.0.115:27017\
MONGODB_PORT_27017_TCP=tcp://172.17.0.115:27017\
MONGODB_PORT_27017_TCP_ADDR=172.17.0.115\
MONGODB_PORT_27017_TCP_PORT=27017\
MONGODB_PORT_27017_TCP_PROTO=tcp\
MONGODB_NAME=/node1/mongodb\
HOME=/root\
\

\f0\b # run: options
\f1\b0 \
-d 			run as daemon (in the background)\
-e 			sets environment variable, can be used, multiple times, vars accessable via $MYVAR1, 			$MYVAR2 - is executed after --env-file, so you can overwrite settings here\
--env-file	sets environment variables based on file contents\
-i 			interactive, keep STDIN open\
--link		links one container to another, takes the form of name:alias (name is the container to 			be linked to, alias is the name you want to use for reference (in the linked 			container)), when linking to containers the source container (ex. you database) does 			not have to expose ports, --link creates a secure tunnel between both of the 			containers - that is a huge benefit, ex. you database is not exposed to the network, 			when --link(ing) docker adds a host entry for the source container\
--name		running containers get random names by default, ex. `cocky_leakey`, you can set the 			name yourself using the --name=NAME option\
-P 			publish all container ports to host\
-p 80:80	publish specific container ports to host, -p flag can be used multiple times to expose 			multiple ports\
--rm		setting the --rm flag will remove the container immediately after it stopped, helps to 			keep you system clean\
-t			opens container's terminal (necessary to run shell, ex: /bin/bash)\
-v			add data volume to container, you can use -v multiple times, btw same as useing the 			VOLUME instruction in a Dockerfile, there are two ways to use -v:\

\f0\b 			1. add volume in container: -v local
\f1\b0 \
			ex: -v /var/www\
			In this case docker will create a directory in your hosts `/var/lib/docker/volumes` 			directory, will be deleted if no container is using it anymore.\

\f0\b 			2. add volume in container and mount a directory from host, -v local:container, local 
\f1\b0 			folders have to have the form of absoluet paths, this option is not available in the 			Dockerfile (because it's specific to one local environment only) \
			ex: -v /Users/mfu/brnfck/test/www/project-node:/var/www\
\

\f0\b # stop, kill
\f1\b0 \
# stop container\
$ docker stop [CONTAINER]\
\
# kill container\
$ docker kill [CONTAINER]\
\

\f0\b # top
\f1\b0 \
# get basic top information about container\
$ docker top [CONTAINER]}